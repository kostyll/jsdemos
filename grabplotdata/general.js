// Generated by CoffeeScript 1.8.0
var ColorsPanel, DataExporter, DemoPage, ImageMatrix, LabeledInput, PlotData, PlotOptionsForm, State, ToolBox, WorkSpace, prepare, state;

DataExporter = function() {
  this.uri = {
    excel: 'data:application/vnd.ms-excel;base64,',
    csv: 'data:application/csv;base64,'
  };
  this.template = {
    excel: '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><!--[if gte mso 9]><xml><x:ExcelWorkbook><x:ExcelWorksheets><x:ExcelWorksheet><x:Name>{worksheet}</x:Name><x:WorksheetOptions><x:DisplayGridlines/></x:WorksheetOptions></x:ExcelWorksheet></x:ExcelWorksheets></x:ExcelWorkbook></xml><![endif]--></head><body><table>{table}</table></body></html>'
  };
};

DataExporter.prototype.getContextForExportClickHandlerFromTextAreaForLink = function(clicked_element_id, area_id) {
  return {
    link: document.getElementById(clicked_element_id),
    raw_data: document.getElementById(area_id).value
  };
};

DataExporter.prototype.getExportCSVClickHandlerFromTextAreaForLink = function(clicked_element_id, area_id) {
  var that, wrapper;
  that = this;
  wrapper = function() {
    var context, href_data;
    context = that.getContextForExportClickHandlerFromTextAreaForLink(clicked_element_id, area_id);
    href_data = that.uri.csv + Base64.encode64(context.raw_data);
    context.link.href = href_data;
  };
  return wrapper;
};

DataExporter.prototype._excell_format = function(s, c) {
  return s.replace(new RegExp("{(\\w+)}", "g"), function(m, p) {
    return c[p];
  });
};

DataExporter.prototype._prepare_csv_string_to_excell_table = function(raw_data) {
  var cell, cells, line, result, _i, _j, _len, _len1, _ref;
  result = "";
  _ref = raw_data.split('\n');
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    line = _ref[_i];
    result += "<tr>";
    cells = line.split(",");
    for (_j = 0, _len1 = cells.length; _j < _len1; _j++) {
      cell = cells[_j];
      result += "<td>" + cell + "</td>";
    }
    result += "</tr>";
  }
  return result;
};

DataExporter.prototype.getExportExcelClickHandlerFromTextAreaForLink = function(clicked_element_id, area_id, name) {
  var that, wrapper;
  that = this;
  wrapper = function() {
    var context, excel_context, href_data;
    context = that.getContextForExportClickHandlerFromTextAreaForLink(clicked_element_id, area_id);
    excel_context = {
      worksheet: name || "WorkSheet0",
      table: that._prepare_csv_string_to_excell_table(context.raw_data)
    };
    href_data = that.uri.excel + Base64.encode64(that._excell_format(that.template.excel, excel_context));
    return context.link.href = href_data;
  };
  return wrapper;
};

DataExporter.prototype.getExportPNGClickHandlerFromDivForLink = function(clicked_element_id, div_id) {
  var wrapper;
  wrapper = function() {
    var div, link;
    link = document.getElementById(clicked_element_id);
    div = document.getElementById(div_id);
    return html2canvas(div, {
      onrendered: function(canvas) {
        var resultCanvasData;
        resultCanvasData = canvas.toDataURL('png');
        return link.href = resultCanvasData;
      }
    });
  };
  return wrapper;
};

LabeledInput = React.createClass({
  getInitialState: function() {
    return {
      value: this.props.value || 0,
      label: this.props.label || this.props.name
    };
  },
  onChange: function(event) {
    this.setState({
      value: event.target.value
    });
    this.props.onChange(this.props.name, event.target.value);
  },
  render: function() {
    return React.createElement(React.DOM.form, {
      "className": "form-horizontal"
    }, React.createElement(React.DOM.div, {
      "className": "control-group"
    }, React.createElement(React.DOM.label, {
      "className": "control-label",
      "for": this.props.id
    }, this.state.label), React.createElement(React.DOM.div, {
      "className": "controls"
    }, React.createElement(React.DOM.input, {
      "type": "text",
      "className": this.props.className + " input-small",
      "id": this.props.id,
      "onChange": this.onChange,
      "placeholder": this.props.value
    }))));
  }
});

PlotOptionsForm = React.createClass({
  getInitialState: function() {
    return {
      activated: this.props.activated,
      color: null,
      calibrated: this.props.calibrated,
      calibrateData: {
        currentIndex: 0,
        x1: 0,
        x2: 0,
        y1: 0,
        y2: 0,
        pointObjects: []
      },
      gx1: 0,
      gx2: 0,
      gy1: 0,
      gy2: 0,
      points: [],
      name: this.props.name || "",
      title: this.props.title || "untitled"
    };
  },
  componentDidMount: function() {
    return this.props.onAfterDidMountPlot(this);
  },
  HeadClickHandler: function() {
    var activated;
    activated = this.state.activated;
    if (activated === true) {
      activated = false;
    } else {
      activated = true;
    }
    this.setState({
      activated: activated
    });
    this.props.onActivatePlot(this.props.id);
  },
  handleSelectColor: function(event) {
    console.log("Selecting color");
    return console.log(event);
  },
  transformPixelToPoint: function(pixel) {
    var AC, AX1, AX1px, DE, DY1, DY1px, X2C, X2Cpx, Y2E, Y2Epx, c, gx1, gx2, gy1, gy2, h, px, py, rgx1, rgx2, rgy1, rgy2, rx1, rx2, ry1, ry2, s, w, x, x1, x2, y, y1, y2;
    w = 600;
    h = 400;
    x = pixel.x;
    y = h - pixel.y;
    s = this.state;
    c = s.calibrateData;
    x1 = Number(c.x1);
    x2 = Number(c.x2);
    y1 = Number(c.y1);
    y2 = Number(c.y2);
    gx1 = Number(s.gx1);
    gx2 = Number(s.gx2);
    gy1 = Number(s.gy1);
    gy2 = Number(s.gy2);
    AC = (1.0 * (gx2 - gx1)) * w / (x2 - x1);
    AX1px = x1 - 0;
    X2Cpx = w - x2;
    AX1 = AC * AX1px / w;
    X2C = AC * X2Cpx / w;
    DE = (1.0 * (gy2 - gy1)) * h / (y2 - y1);
    DY1px = y1 - 0;
    Y2Epx = h - y2;
    DY1 = DE * DY1px / h;
    Y2E = DE * Y2Epx / h;
    rx1 = 0;
    rx2 = w;
    ry1 = 0;
    ry2 = h;
    rgx1 = gx1 - AX1;
    rgx2 = gx2 + X2C;
    rgy1 = gy1 - DY1;
    rgy2 = gy2 + Y2E;
    px = rgx1 + ((1.0 * x) / Math.abs(rx2 - rx1)) * Math.abs(rgx2 - rgx1);
    py = rgy1 + ((1.0 * y) / Math.abs(ry2 - ry1)) * Math.abs(rgy2 - rgy1);
    return {
      x: px,
      y: py
    };
  },
  handleCalibrate: function(event) {
    var that;
    that = this;
    console.log("Calibrate");
    console.log(event);
    return this.props.onChangeState({
      name: "calibrate",
      callback: function(x, y, obj) {
        var calibrateData, calibrated, index, point, _i, _len, _ref;
        calibrateData = that.state.calibrateData;
        index = calibrateData.currentIndex;
        calibrated = false;
        if (index === 0) {
          _ref = calibrateData.pointObjects;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            point = _ref[_i];
            state.canvas.remove(point);
          }
          calibrateData.pointObjects = [];
          calibrateData.x1 = x;
          calibrateData.pointObjects.push(obj);
        } else if (index === 1) {
          calibrateData.x2 = x;
          calibrateData.pointObjects.push(obj);
        } else if (index === 2) {
          calibrateData.y1 = 400 - y;
          calibrateData.pointObjects.push(obj);
        } else if (index === 3) {
          calibrateData.y2 = 400 - y;
          calibrateData.pointObjects.push(obj);
        }
        index = index + 1;
        if (index === 4) {
          index = 0;
          that.props.onChangeState(null);
          calibrated = true;
          alert("Done");
          that.props.onChangeState(null);
        }
        calibrateData.currentIndex = index;
        return that.setState({
          calibrated: calibrated,
          calibrateData: calibrateData
        });
      }
    });
  },
  handleDetectPoints: function(event) {
    console.log("Detecting points");
    return this.props.onChangeState({
      name: "detect",
      callback: function() {
        return console.log(arguments);
      }
    });
  },
  handleChoisePoints: function(event) {
    var that;
    console.log("Choising points");
    that = this;
    if (that.state.calibrated === false) {
      alert("Not calibrated");
      return;
    }
    return this.props.onChangeState({
      name: "select",
      callback: function(x, y, obj) {
        var pixel, point, points;
        if (that.state.calibrated === false) {
          alert("Not calibrated");
          return;
        }
        console.log(arguments);
        points = that.state.points;
        pixel = {
          x: x,
          y: y
        };
        point = that.transformPixelToPoint(pixel);
        point.obj = obj;
        points.push(point);
        return that.setState({
          points: points
        });
      }
    });
  },
  updateLabeledInput: function(name, value) {
    var state;
    state = this.state;
    state[name] = value;
    return this.setState(state);
  },
  showOwnPoints: function() {
    var point, points, _i, _j, _len, _len1;
    points = this.state.points;
    for (_i = 0, _len = points.length; _i < _len; _i++) {
      point = points[_i];
      point.obj.bringToFront();
    }
    points = this.state.calibrateData.pointObjects;
    for (_j = 0, _len1 = points.length; _j < _len1; _j++) {
      point = points[_j];
      point.bringToFront();
    }
    if (state.canvas === !null) {
      return state.canvas.renderAll();
    }
  },
  hideOwnPoints: function() {
    var point, points, _i, _j, _len, _len1;
    points = this.state.points;
    for (_i = 0, _len = points.length; _i < _len; _i++) {
      point = points[_i];
      point.obj.sendBackwards(true);
    }
    points = this.state.calibrateData.pointObjects;
    for (_j = 0, _len1 = points.length; _j < _len1; _j++) {
      point = points[_j];
      point.sendBackwards();
    }
    if (state.canvas === !null) {
      return state.canvas.renderAll();
    }
  },
  renderHead: function() {
    return React.createElement(React.DOM.button, {
      "className": "btn btn-primary",
      "onClick": this.HeadClickHandler
    }, this.state.name);
  },
  render: function() {
    var s;
    s = this.state;
    console.log(this.state.points);
    if (s.activated === true) {
      this.showOwnPoints();
      return React.createElement(React.DOM.div, null, React.createElement(LabeledInput, {
        "label": "Plot name",
        "id": this.props.id,
        "name": "name",
        "value": this.state.name,
        "onChange": this.updateLabeledInput
      }), React.createElement(React.DOM.button, {
        "className": "btn btn-small",
        "onClick": this.handleSelectColor
      }, "Select color"), React.createElement(React.DOM.button, {
        "className": "btn btn-small",
        "onClick": this.handleCalibrate
      }, "Calibrate"), React.createElement(React.DOM.button, {
        "className": "btn btn-small",
        "onClick": this.handleDetectPoints
      }, "Detect points"), React.createElement(React.DOM.button, {
        "className": "btn btn-small",
        "onClick": this.handleChoisePoints
      }, "Choise plot points"), React.createElement(LabeledInput, {
        "id": this.props.id,
        "name": "gx1",
        "value": s.gx1,
        "onChange": this.updateLabeledInput
      }), React.createElement(LabeledInput, {
        "id": this.props.id,
        "name": "gx2",
        "value": s.gx2,
        "onChange": this.updateLabeledInput
      }), React.createElement(LabeledInput, {
        "id": this.props.id,
        "name": "gy1",
        "value": s.gy1,
        "onChange": this.updateLabeledInput
      }), React.createElement(LabeledInput, {
        "id": this.props.id,
        "name": "gy2",
        "value": s.gy2,
        "onChange": this.updateLabeledInput
      }));
    } else {
      this.hideOwnPoints();
      return React.createElement(React.DOM.div, null, this.renderHead());
    }
  }
});

ToolBox = React.createClass({
  getInitialState: function() {
    var items;
    items = [];
    this.props.items.forEach(function(item, index, arr) {
      return items.push({
        index: index,
        value: item
      });
    });
    return {
      activeItem: 0,
      items: items,
      displayAll: false
    };
  },
  componentDidMount: function() {
    console.log(this.props);
    return this.props.onInstallToolbox(this);
  },
  addNewPlot: function() {
    var items;
    items = this.state.items;
    items.push({
      index: items.length,
      value: "New plot"
    });
    return this.setState({
      items: items
    });
  },
  changeDisplayAll: function() {
    var currentValue;
    currentValue = this.state.displayAll;
    if (currentValue === true) {
      currentValue = false;
    } else {
      currentValue = true;
    }
    this.setState({
      displayAll: currentValue
    });
    console.log("checked=>");
    console.log(currentValue);
    return this.props.root.state.plotDataInstance.refreshPlot();
  },
  render: function() {
    var that;
    that = this;
    return React.createElement(React.DOM.div, {
      "id": "toolbox"
    }, React.createElement(React.DOM.h3, null, "Toolbox:"), React.createElement(React.DOM.button, {
      "className": "btn btn-large btn-primary",
      "onClick": this.addNewPlot
    }, "Add new plot"), React.createElement(React.DOM.label, {
      "for": "displayAll"
    }, "Display all"), React.createElement(React.DOM.input, {
      "id": "displayAll",
      "type": "checkbox",
      "checked": this.state.displayAll,
      "onChange": this.changeDisplayAll
    }), this.state.items.map(function(item) {
      return React.createElement(PlotOptionsForm, {
        "id": item.index,
        "name": item.value,
        "onAfterDidMountPlot": that.props.onAfterDidMountPlot,
        "onActivatePlot": that.props.onActivatePlot,
        "activated": item.index === that.props.activePlot,
        "onChangeState": that.props.onChangeState,
        "calibrated": false
      });
    }));
  }
});

ColorsPanel = React.createClass({
  renderColors: function(colors) {
    var dominantColor;
    console.log(colors);
    dominantColor = colors.dominantColor;
    colors = colors.palette;
    colors.push(dominantColor);
    console.log(colors);
    return React.createElement(React.DOM.table, null, React.createElement(React.DOM.tr, null, colors.map(function(item, index) {
      return React.createElement(React.DOM.td, {
        "className": "swatch",
        "style": {
          backgroundColor: "rgb(" + item[0] + ", " + item[1] + ", " + item[2] + ")",
          width: 20,
          height: 20
        }
      });
    })), React.createElement(React.DOM.tr, null, colors.map(function(item, index) {
      var color;
      color = [item[0], item[1], item[2]];
      console.log(color);
      return React.createElement(React.DOM.td, {
        "className": "swatch",
        "style": {
          backgroundColor: "rgb(" + color[0] + ", " + color[1] + ", " + color[2] + ")",
          width: 20,
          height: 20
        }
      });
    })));
  },
  render: function() {
    var colors;
    colors = this.props.colors;
    if (!(colors === null)) {
      return React.createElement(React.DOM.div, null, React.createElement(React.DOM.h3, null, "Colors:"), this.renderColors(colors));
    } else {
      return React.createElement(React.DOM.div, null, React.createElement(React.DOM.h3, null, "Colors:"));
    }
  }
});

WorkSpace = React.createClass({
  getInitialState: function() {
    return {
      plot_url: null,
      colors: null
    };
  },
  getColors: function(image, colorscount) {
    var colorThief, dominantColor, palette;
    if (colorscount == null) {
      colorscount = 15;
    }
    colorThief = new ColorThief();
    dominantColor = colorThief.getColor(image);
    palette = colorThief.getPalette(image, colorscount);
    return {
      dominantColor: dominantColor,
      palette: palette
    };
  },
  loadImage: function(image, that) {
    var imgObj;
    imgObj = new fabric.Image(image);
    imgObj.set({
      angle: 0,
      width: 600,
      height: 400,
      selectable: false
    });
    state.canvas.centerObject(imgObj);
    state.canvas.add(imgObj);
    state.canvas.renderAll();
    that.setState({
      colors: that.getColors(image)
    });
    that.render();
    that.props.onImageLoad(imgObj);
  },
  selectFileHandler: function(event) {
    var reader, selected_file, that;
    console.log("Selecting file...");
    that = this;
    state.file_image = event.target.files[0];
    selected_file = document.getElementById("selected-file");
    reader = new FileReader();
    reader.onload = function(e) {
      var image;
      image = new Image();
      image.onload = function() {
        console.log("Image selected");
        that.loadImage(image, that);
      };
      image.src = reader.result;
    };
    reader.readAsDataURL(state.file_image);
  },
  onChagePlotUrl: function(event) {
    return this.setState({
      plot_url: event.target.value
    });
  },
  onLoadImagePlot: function() {
    var image, that;
    console.log("Loading file...");
    that = this;
    image = new Image();
    image.onload = function() {
      that.loadImage(image, that);
    };
    image.src = this.state.plot_url;
  },
  componentDidMount: function() {
    document.getElementById("selected-file").addEventListener("change", this.selectFileHandler);
    return this.props.onAfterDidMountWorkSpace(this);
  },
  render: function() {
    return React.createElement(React.DOM.div, {
      "className": "row-fluid"
    }, React.createElement(React.DOM.h3, null, "Workspace:"), React.createElement(React.DOM.ul, {
      "className": "nav nav-tabs",
      "role": "tablist"
    }, React.createElement(React.DOM.li, {
      "className": "active"
    }, React.createElement(React.DOM.a, {
      "role": "tab",
      "data-toggle": "tab",
      "href": "#source_image_file"
    }, "File")), React.createElement(React.DOM.li, null, React.createElement(React.DOM.a, {
      "role": "tab",
      "data-toggle": "tab",
      "href": "#source_image_url"
    }, "URL"))), React.createElement(React.DOM.div, {
      "className": "tab-content"
    }, React.createElement(React.DOM.div, {
      "className": "tab-pane active",
      "id": "source_image_file"
    }, React.createElement(React.DOM.span, {
      "className": "btn btn-file"
    }, React.createElement(React.DOM.input, {
      "id": "selected-file",
      "type": "file",
      "className": "form-control"
    }))), React.createElement(React.DOM.div, {
      "className": "tab-pane",
      "id": "source_image_url"
    }, React.createElement(React.DOM.form, {
      "className": "form-horizontal"
    }, React.createElement(React.DOM.div, {
      "className": "control-group"
    }, React.createElement(React.DOM.label, {
      "className": "control-label",
      "for": "source_url"
    }, "Plot url"), React.createElement(React.DOM.div, {
      "className": "controls"
    }, React.createElement(React.DOM.input, {
      "type": "text",
      "className": "input",
      "id": "source_url",
      "onChange": this.onChagePlotUrl,
      "placeholder": "http://imageurl"
    }), React.createElement(React.DOM.a, {
      "className": "btn btn-small btn-primary",
      "onClick": this.onLoadImagePlot
    }, "Load")))))), React.createElement(ColorsPanel, {
      "colors": this.state.colors
    }), React.createElement(React.DOM.div, {
      "id": "image-container"
    }, React.createElement(React.DOM.canvas, {
      "id": "image",
      "width": "600px",
      "height": "400"
    })));
  }
});

PlotData = React.createClass({
  getInitialState: function() {
    return {
      changed: new Date()
    };
  },
  componentDidMount: function() {
    return this.props.tellRootAboutSelf(this);
  },
  refresh: function() {
    console.log("refreshing ...");
    return this.setState({
      changed: new Date()
    });
  },
  renderPlotPoints: function() {
    var csv_data, plot, tableBody;
    console.log("Rendering table");
    if (this.props.plotsDataProvider.state.plots.length === 0) {
      return;
    }
    plot = this.props.plotsDataProvider.state.plots[this.props.plotsDataProvider.state.activePlot].state;
    csv_data = "";
    tableBody = React.createElement(React.DOM.tbody, null, plot.points.map(function(item, index) {
      csv_data += item.x + ',' + item.y + '\n';
      return React.createElement(React.DOM.tr, null, React.createElement(React.DOM.td, null, index), React.createElement(React.DOM.td, null, item.x), React.createElement(React.DOM.td, null, item.y));
    }));
    return {
      tableBody: tableBody,
      csv: csv_data
    };
  },
  refreshPlot: function() {
    var activePlot, displayAll, plots;
    if (this.props.plotsDataProvider.state.plots.length === 0) {
      return;
    }
    console.log("Toolbox ==>");
    console.log(this.props.plotsDataProvider.state.toolbox);
    if (!(this.props.plotsDataProvider.state.toolbox === null)) {
      console.log("Selecting toolbox property...");
      displayAll = !this.props.plotsDataProvider.state.toolbox.state.displayAll;
    } else {
      displayAll = false;
    }
    console.log("DisplayAll=>");
    console.log(displayAll);
    plots = [];
    activePlot = this.props.plotsDataProvider.state.activePlot;
    this.props.plotsDataProvider.state.plots.map(function(item, index) {
      var currentPlotPoints, points;
      if (displayAll || (!displayAll && index === activePlot)) {
        points = [];
        currentPlotPoints = item.state.points;
        currentPlotPoints.map(function(item, index) {
          return points.push([item.x, item.y]);
        });
        return plots.push(points);
      }
    });
    console.log("Plots ====>");
    console.log(plots);
    $.plot($("#plot-graphic"), plots);
  },
  getCurrentPlotName: function() {
    console.log(this.props.plotsDataProvider.state.plots);
    console.log(this.props.plotsDataProvider.state.activePlot);
    if (this.props.plotsDataProvider.state.plots[this.props.plotsDataProvider.state.activePlot] === !void 0) {
      return this.props.plotsDataProvider.state.plots[this.props.plotsDataProvider.state.activePlot].state.name;
    } else {
      return "untitled";
    }
  },
  render: function() {
    var rendered_table;
    rendered_table = this.renderPlotPoints();
    return React.createElement(React.DOM.div, {
      "className": "row-fluid"
    }, React.createElement(React.DOM.h3, null, "Plot-data:"), React.createElement(React.DOM.ul, {
      "className": "nav nav-tabs",
      "role": "tablist"
    }, React.createElement(React.DOM.li, {
      "className": "active"
    }, React.createElement(React.DOM.a, {
      "role": "tab",
      "data-toggle": "tab",
      "href": "#table"
    }, "Table")), React.createElement(React.DOM.li, null, React.createElement(React.DOM.a, {
      "role": "tab",
      "data-toggle": "tab",
      "href": "#csv"
    }, "Export")), React.createElement(React.DOM.li, null, React.createElement(React.DOM.a, {
      "role": "tab",
      "data-toggle": "tab",
      "href": "#plot"
    }, "Plot"))), React.createElement(React.DOM.div, {
      "className": "tab-content"
    }, React.createElement(React.DOM.div, {
      "className": "tab-pane active",
      "id": "table"
    }, React.createElement(React.DOM.table, {
      "id": "plot-points",
      "className": "table table-bordered"
    }, React.createElement(React.DOM.thead, null, React.createElement(React.DOM.th, null, "Index"), React.createElement(React.DOM.th, null, "X"), React.createElement(React.DOM.th, null, "Y")), (rendered_table ? rendered_table.tableBody : void 0))), React.createElement(React.DOM.div, {
      "className": "tab-pane",
      "id": "csv"
    }, React.createElement(React.DOM.textarea, {
      "id": "export_data",
      "value": (rendered_table ? rendered_table.csv : void 0)
    }), React.createElement(React.DOM.br, null), React.createElement(React.DOM.a, {
      "id": "csv_export_link",
      "className": "btn btn-small btn-primary",
      "download": this.getCurrentPlotName() + '.csv',
      "onClick": new DataExporter().getExportCSVClickHandlerFromTextAreaForLink("csv_export_link", "export_data")
    }, "Export as CSV"), React.createElement(React.DOM.a, {
      "id": "excel_export_link",
      "className": "btn btn-small btn-primary",
      "download": this.getCurrentPlotName() + '.xls',
      "onClick": new DataExporter().getExportExcelClickHandlerFromTextAreaForLink("excel_export_link", "export_data")
    }, "Export as Excel")), React.createElement(React.DOM.div, {
      "className": "tab-pane",
      "id": "plot"
    }, React.createElement(React.DOM.div, {
      "id": "plot-graphic",
      "style": {
        width: 500,
        height: 300
      }
    }), this.refreshPlot(), React.createElement(React.DOM.a, {
      "id": "png_export_link",
      "className": "btn btn-small btn-primary",
      "download": this.getCurrentPlotName() + '.png',
      "onClick": new DataExporter().getExportPNGClickHandlerFromDivForLink("png_export_link", "plot-graphic")
    }, "Export as PNG"))));
  }
});

DemoPage = React.createClass({
  getInitialState: function() {
    return {
      activePlot: 0,
      plots: [],
      lastplot: 0,
      workspace: null,
      putNewPoints: true,
      state: null,
      image: null,
      toolbox: null
    };
  },
  getPlotDataInstance: function(instance) {
    return this.setState({
      plotDataInstance: instance
    });
  },
  onChangeState: function(state) {
    console.log(state);
    return this.setState({
      state: state
    });
  },
  onActivatePlot: function(index) {
    this.state.plots[this.state.activePlot].setState({
      activated: false
    });
    this.setState({
      activePlot: index
    });
    return this.state.plotDataInstance.refreshPlot();
  },
  onAfterDidMountPlot: function(plot_data) {
    var parent_calibrateData, parent_calibrated, parent_plot, plots;
    plots = this.state.plots;
    plots.push(plot_data);
    this.setState({
      plots: plots
    });
    parent_plot = this.state.plots[this.state.activePlot];
    parent_calibrated = parent_plot.state.calibrated;
    parent_calibrateData = new Object(parent_plot.state.calibrateData);
    return plot_data.setState({
      calibrated: parent_calibrated,
      calibrateData: parent_calibrateData,
      gx1: parent_plot.state.gx1,
      gx2: parent_plot.state.gx2,
      gy1: parent_plot.state.gy1,
      gy2: parent_plot.state.gy2
    });
  },
  onAfterDidMountWorkSpace: function(workspace) {
    return this.setState({
      workspace: workspace
    });
  },
  onImageLoad: function(image) {
    var plot, _i, _len, _ref;
    this.setState({
      image: image
    });
    _ref = this.state.plots;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      plot = _ref[_i];
      plot.setState({
        calibrated: false
      });
    }
  },
  onInstallToolbox: function(toolbox_instance) {
    return this.setState({
      toolbox: toolbox_instance
    });
  },
  switchOnPlotPointsPut: function() {
    return this.setState({
      putNewPoints: true
    });
  },
  switchOffPlotPointsPut: function() {
    return this.setState({
      putNewPoints: false
    });
  },
  putNewPoints: function(flag) {
    if (flag === true) {
      return this.switchOnPlotPointsPut();
    } else {
      return this.switchOffPlotPointsPut;
    }
  },
  putSelectedPoint: function(x, y, callback) {
    var R, circle;
    R = 3;
    circle = new fabric.Circle({
      left: x - Math.floor(R / 2),
      top: y - Math.floor(R / 2),
      radius: R,
      fill: "red",
      selectable: false
    });
    state.canvas.add(circle);
    callback(x, y, circle);
    return this.state.plotDataInstance.refresh();
  },
  putCalibratedPoint: function(x, y, callback) {
    var R, rect;
    R = 5;
    rect = new fabric.Rect({
      left: x - Math.floor(R / 2),
      top: y - Math.floor(R / 2),
      width: 2 * R,
      height: 2 * R,
      fill: "green",
      selectable: false
    });
    state.canvas.add(rect);
    return callback(x, y, rect);
  },
  detectplot: function(x, y) {
    var color, context, d, data, image_data;
    console.log("detecting ...");
    context = state.canvas.getContext("2d");
    image_data = context.getImageData(x, y, 1, 1);
    data = image_data.data;
    console.log(data);
    d = [data[0], data[1], data[2]].join(",");
    color = new fabric.Color('rgb(' + d + ')');
    alert(color.toHex());
    return console.log("Image data=");
  },
  image_click_handler: function(e) {
    var coordinate, s, x, y;
    console.log(this.state);
    console.log(state.canvas);
    if (this.state.image !== null) {
      console.log("Image clicked");
      console.log(e);
      e = e.e;
      console.log(e);
      coordinate = state.get_image_coordinates_from_client(e.clientX, e.clientY);
      x = coordinate[0];
      y = coordinate[1];
      s = this.state.state;
      if (s === null) {
        return console.log("ups ...");
      } else if (s.name === "calibrate") {
        return this.putCalibratedPoint(x, y, s.callback);
      } else if (s.name === "detect") {
        return this.detectplot(x, y);
      } else if (s.name === "select") {
        console.log("selecting ...");
        return this.putSelectedPoint(x, y, s.callback);
      } else if (s === null) {

      } else {
        return console.log("Ups..");
      }
    } else {
      console.log("Not image loaded");
      return alert("Not image loaded");
    }
  },
  componentDidMount: function() {
    state.canvas = new fabric.Canvas("image");
    state.image_left = state.canvas._offset.left;
    state.image_top = state.canvas._offset.top;
    state.source_image = document.getElementById("image");
    state.canvas.on('mouse:down', this.image_click_handler);
    return console.log(this.state);
  },
  render: function() {
    return React.createElement(React.DOM.div, {
      "className": "row-fluid"
    }, React.createElement(React.DOM.div, {
      "className": "span10"
    }, React.createElement(WorkSpace, {
      "onAfterDidMountWorkSpace": this.onAfterDidMountWorkSpace,
      "onImageLoad": this.onImageLoad
    }), React.createElement(PlotData, {
      "tellRootAboutSelf": this.getPlotDataInstance,
      "plotsDataProvider": this
    })), React.createElement(React.DOM.div, {
      "className": "span2"
    }, React.createElement(ToolBox, {
      "activePlot": this.state.activePlot,
      "items": this.props.items,
      "onAfterDidMountPlot": this.onAfterDidMountPlot,
      "onActivatePlot": this.onActivatePlot,
      "onChangeState": this.onChangeState,
      "onInstallToolbox": this.onInstallToolbox,
      "root": this
    })));
  }
});

State = function() {
  this.file_image = null;
  this.state = "start";
  this.possible_states = ["start", "uploaded", "select-points", "calibrate"];
  this.image_left = 0;
  this.image_top = 0;
  this.image_width = 0;
  this.image_height = 0;
  this.canvas = null;
  this.ctx = 0;
  this.image_matrix = null;
  this.source_image = null;
  return this.canvas = null;
};

State.prototype.changeState = function(state) {
  var that;
  that = this;
  that.state = state;
  return console.log("Changing state to " + String(state));
};

State.prototype.change_image = function(image_html_el) {
  var that;
  that = this;
  that.image_left = image_html_el.offsetLeft;
  that.image_top = image_html_el.offsetTop;
  that.image_width = image_html_el.width;
  that.image_height = image_html_el.height;
  return console.log(this);
};

State.prototype.get_image_coordinates_from_client = function(clientX, clientY) {
  var x, y;
  x = clientX - this.canvas._offset.left;
  y = clientY - this.canvas._offset.top;
  return [x, y];
};

ImageMatrix = function(data) {
  this.source_data = data;
  this.width = data.width;
  return this.height = data.height;
};

state = new State();

prepare = function() {
  var items;
  items = ["Untitled0"];
  return React.render(React.createElement(DemoPage, {
    "items": items
  }), document.getElementById("container"));
};

document.onready = prepare;
